1. What is @Test? (Definition)
--->  It is the primary TestNG annotation used to mark a method as a Test Case.
Purpose: It tells the TestNG engine that the annotated method is not a regular helper method, but a piece of logic that should be executed and reported on (Pass/Fail).
Return Type: Methods marked with @Test must be public and should ideally return void.

2. How it Works (The Execution Process)
---> TestNG scans your project (or the TestNG Class) for the @Test marker.
It uses Reflection API to invoke these methods at runtime.
It wraps each test in a try-catch block internally:
If no exception occurs, the test is marked Passed.
If an AssertionError or any Exception occurs, it is marked Failed.
If a prerequisite is not met, it is marked Skipped.

3. When it Works (The Triggers)
---> A @Test method executes when:
You right-click the class and select Run as TestNG Test.
You run a testng.xml file that includes the class or package. ----or using the xml we can run test suites
Its dependencies (if any) have successfully finished.
It is Enabled (the attribute enabled=true is the default).

4. Priority? (Execution Order)
---> By default, TestNG runs tests in alphabetical order by method name. And to change that order we use the priority attribute.
Syntax: @Test(priority = 1)
Calculation Rules:
Lowest numbers run first: A test with priority = -1 runs before priority = 0.
Default Value: If you don't assign a priority, the default is 0.
Tie-breaking: If two tests have the same priority, they fallback to alphabetical order. 

Types of Test :

1. Unit Testing: Focuses on verifying the smallest parts of the application (like a single method or class) in isolation to ensure logic is correct.

2. Integration Testing: Verifies that different modules or services of the application work correctly when combined together.

3. Smoke Testing: A high-level, "wide but shallow" suite that checks if the most critical functions of the application (like login or checkout) work after a new build.

4. Sanity Testing: A subset of regression testing that focuses on a specific functional area or a bug fix to ensure the changes behave as expected before more rigorous testing.

5. Regression Testing: A comprehensive suite executed after code changes to ensure that new updates have not negatively impacted or "broken" existing features.

6. Functional Testing: Validates the software against the functional requirements or specifications to ensure it does exactly what the user expects.

7. End-to-End (E2E) Testing: Simulates a real user scenario from start to finish (e.g., landing page to final payment) to validate the entire system flow and integration with external interfaces.

8. UI/Screen Testing: Focused specifically on the visual elements and user interface of the application to ensure buttons, fields, and layouts appear and function correctly across screens.

